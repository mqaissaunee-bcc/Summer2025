<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Newton's Method for Systems - Interactive Learning</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            padding: 30px;
            text-align: center;
            color: white;
        }
        
        .header h1 {
            margin: 0;
            font-size: 2.5em;
            font-weight: 300;
        }
        
        .header p {
            margin: 10px 0 0 0;
            opacity: 0.9;
            font-size: 1.1em;
        }
        
        .nav-tabs {
            display: flex;
            background: #f8f9fa;
            border-bottom: 1px solid #e0e0e0;
        }
        
        .nav-tab {
            flex: 1;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            background: #f8f9fa;
            border: none;
            font-size: 1.1em;
            font-weight: 600;
            color: #666;
            transition: all 0.3s ease;
        }
        
        .nav-tab.active {
            background: white;
            color: #4facfe;
            border-bottom: 3px solid #4facfe;
        }
        
        .nav-tab:hover {
            background: #e8f4fd;
            color: #4facfe;
        }
        
        .tab-content {
            display: none;
            padding: 30px;
        }
        
        .tab-content.active {
            display: block;
        }
        
        /* Learning Section Styles */
        .learning-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }
        
        .concept-card {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 25px;
            border-left: 5px solid #4facfe;
        }
        
        .concept-card h3 {
            margin: 0 0 15px 0;
            color: #2c3e50;
            font-size: 1.3em;
        }
        
        .concept-card p {
            line-height: 1.6;
            margin-bottom: 15px;
        }
        
        .formula-box {
            background: white;
            padding: 20px;
            border-radius: 10px;
            margin: 15px 0;
            border: 1px solid #e0e0e0;
            text-align: center;
            font-family: 'Times New Roman', serif;
            font-size: 1.2em;
        }
        
        .step-by-step {
            background: #e8f4fd;
            border-radius: 15px;
            padding: 25px;
            margin: 20px 0;
        }
        
        .step-by-step h3 {
            margin: 0 0 20px 0;
            color: #2c3e50;
        }
        
        .step {
            display: flex;
            align-items: flex-start;
            margin-bottom: 20px;
            padding: 15px;
            background: white;
            border-radius: 10px;
        }
        
        .step-number {
            background: #4facfe;
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin-right: 15px;
            flex-shrink: 0;
        }
        
        .step-content {
            flex: 1;
        }
        
        .step-title {
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 5px;
        }
        
        .matrix-example {
            background: #fff3cd;
            border-radius: 10px;
            padding: 20px;
            margin: 15px 0;
            border-left: 4px solid #ffc107;
        }
        
        .matrix-example h4 {
            margin: 0 0 15px 0;
            color: #856404;
        }
        
        .matrix {
            font-family: 'Courier New', monospace;
            font-size: 1.1em;
            text-align: center;
            background: white;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
        }
        
        /* Simulation Section Styles */
        .main-content {
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 30px;
        }
        
        .visualization-panel {
            background: #fafafa;
            border-radius: 15px;
            padding: 20px;
            text-align: center;
        }
        
        canvas {
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            background: white;
            max-width: 100%;
        }
        
        .controls {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 25px;
        }
        
        .control-group {
            margin-bottom: 25px;
        }
        
        .control-group h3 {
            margin: 0 0 15px 0;
            color: #2c3e50;
            font-size: 1.1em;
            font-weight: 600;
        }
        
        .system-btn {
            display: block;
            width: 100%;
            padding: 15px;
            margin-bottom: 10px;
            border: 2px solid #e0e0e0;
            background: white;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: left;
        }
        
        .system-btn:hover {
            border-color: #4facfe;
            transform: translateY(-2px);
        }
        
        .system-btn.active {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            border-color: #4facfe;
        }
        
        .system-name {
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .system-equations {
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
            opacity: 0.8;
        }
        
        .starting-point {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .input-group {
            display: flex;
            flex-direction: column;
        }
        
        .input-group label {
            font-weight: 500;
            color: #555;
            margin-bottom: 5px;
        }
        
        .input-group input {
            padding: 10px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-size: 1em;
        }
        
        .input-group input:focus {
            outline: none;
            border-color: #4facfe;
        }
        
        .action-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        button {
            padding: 12px 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.9em;
            transition: all 0.3s ease;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
        }
        
        .btn-secondary {
            background: #f8f9fa;
            color: #666;
            border: 2px solid #e0e0e0;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .info-panel {
            background: white;
            border-radius: 10px;
            padding: 20px;
            border-left: 4px solid #4facfe;
        }
        
        .iteration-info {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 15px;
        }
        
        .info-item {
            text-align: center;
        }
        
        .info-value {
            font-size: 1.2em;
            font-weight: bold;
            color: #2c3e50;
            display: block;
            font-family: 'Courier New', monospace;
        }
        
        .info-label {
            font-size: 0.9em;
            color: #666;
            margin-top: 5px;
        }
        
        .current-values {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }
        
        .current-values h4 {
            margin: 0 0 10px 0;
            color: #2c3e50;
        }
        
        .values-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        
        .value-item {
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        .jacobian-display {
            background: #e8f4fd;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }
        
        .jacobian-display h4 {
            margin: 0 0 10px 0;
            color: #2c3e50;
        }
        
        .explanation {
            background: #fff3cd;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
        }
        
        .debug {
            background: #ffe6e6;
            padding: 10px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 0.8em;
            margin-top: 10px;
        }
        
        @media (max-width: 1200px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            
            .learning-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Newton's Method for Nonlinear Systems</h1>
            <p>Interactive learning tool for understanding the Jacobian matrix and system solving</p>
        </div>
        
        <div class="nav-tabs">
            <button class="nav-tab active" onclick="showTab('learning')">📚 Learn the Theory</button>
            <button class="nav-tab" onclick="showTab('simulation')">🎯 Interactive Simulation</button>
            <button class="nav-tab" onclick="showTab('code')">💻 MATLAB Code</button>
        </div>
        
        <!-- Learning Tab -->
        <div id="learning" class="tab-content active">
            <div class="learning-grid">
                <div class="concept-card">
                    <h3>🎯 What is Newton's Method for Systems?</h3>
                    <p>Newton's method extends from finding roots of single equations f(x) = 0 to solving systems of nonlinear equations:</p>
                    <div class="formula-box">
                        f₁(x₁, x₂, ..., xₙ) = 0<br>
                        f₂(x₁, x₂, ..., xₙ) = 0<br>
                        ⋮<br>
                        fₙ(x₁, x₂, ..., xₙ) = 0
                    </div>
                    <p>Instead of using the derivative, we use the <strong>Jacobian matrix</strong> containing all partial derivatives.</p>
                </div>
                
                <div class="concept-card">
                    <h3>🧮 The Jacobian Matrix</h3>
                    <p>The Jacobian J is a matrix of first-order partial derivatives. For a 2×2 system:</p>
                    <div class="formula-box">
                        J = [∂f₁/∂x  ∂f₁/∂y]<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;[∂f₂/∂x  ∂f₂/∂y]
                    </div>
                    <p>This matrix tells us how each function changes with respect to each variable - it's the multivariable generalization of the derivative!</p>
                </div>
            </div>
            
            <div class="step-by-step">
                <h3>🔄 Newton's Method Algorithm (Step by Step)</h3>
                
                <div class="step">
                    <div class="step-number">1</div>
                    <div class="step-content">
                        <div class="step-title">Choose Initial Guess</div>
                        Pick a starting point <strong>x⁰ = (x₀, y₀)</strong> hopefully close to the solution.
                    </div>
                </div>
                
                <div class="step">
                    <div class="step-number">2</div>
                    <div class="step-content">
                        <div class="step-title">Evaluate Functions</div>
                        Calculate <strong>F(xᵏ) = [f₁(xᵏ), f₂(xᵏ)]ᵀ</strong> - the vector of function values.
                    </div>
                </div>
                
                <div class="step">
                    <div class="step-number">3</div>
                    <div class="step-content">
                        <div class="step-title">Compute Jacobian</div>
                        Calculate the Jacobian matrix <strong>J(xᵏ)</strong> at the current point.
                    </div>
                </div>
                
                <div class="step">
                    <div class="step-number">4</div>
                    <div class="step-content">
                        <div class="step-title">Solve Linear System</div>
                        Solve <strong>J(xᵏ) Δx = -F(xᵏ)</strong> for the step Δx, or equivalently: <strong>Δx = -J⁻¹(xᵏ) F(xᵏ)</strong>
                    </div>
                </div>
                
                <div class="step">
                    <div class="step-number">5</div>
                    <div class="step-content">
                        <div class="step-title">Update Solution</div>
                        Update: <strong>xᵏ⁺¹ = xᵏ + Δx</strong>
                    </div>
                </div>
                
                <div class="step">
                    <div class="step-number">6</div>
                    <div class="step-content">
                        <div class="step-title">Check Convergence</div>
                        If <strong>||F(xᵏ⁺¹)|| < tolerance</strong>, stop. Otherwise, return to step 2.
                    </div>
                </div>
            </div>
            
                <div class="matrix-example">
                <h4>📊 Example: Circle and Line Intersection</h4>
                <p>Let's find where a unit circle intersects the line x = y:</p>
                <div class="matrix">
                    f₁(x,y) = x² + y² - 1 = 0<br>
                    f₂(x,y) = x - y = 0
                </div>
                <p><strong>Jacobian Matrix:</strong></p>
                <div class="matrix">
                    J(x,y) = [2x   2y]<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[1   -1]
                </div>
                <p>At point (0.8, 0.2):</p>
                <div class="matrix">
                    J(0.8, 0.2) = [1.6   0.4]<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[1    -1]
                </div>
                
                <h4 style="margin-top: 20px;">🔥 Complex Nonlinear Example</h4>
                <p>For the challenging system with exponential terms:</p>
                <div class="matrix">
                    f₁(x,y) = (x-y)² - 1 = 0<br>
                    f₂(x,y) = e^x - y - 2 = 0
                </div>
                <p><strong>Jacobian Matrix:</strong></p>
                <div class="matrix">
                    J(x,y) = [2(x-y)   -2(x-y)]<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[e^x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1]
                </div>
            </div>
            
            <div class="concept-card" style="grid-column: 1 / -1;">
                <h3>🎯 Why Does This Work?</h3>
                <p>Newton's method works by:</p>
                <ul style="line-height: 1.8;">
                    <li><strong>Linear Approximation:</strong> At each step, we approximate the nonlinear functions with linear functions using the Jacobian</li>
                    <li><strong>Root Finding:</strong> We solve the linear system to find where these linear approximations equal zero</li>
                    <li><strong>Iteration:</strong> This gives us a better guess, and we repeat the process</li>
                    <li><strong>Quadratic Convergence:</strong> When close to the solution, Newton's method converges very quickly (error roughly squares each iteration)</li>
                </ul>
                <p><strong>Key Insight:</strong> The Jacobian tells us the "direction" to move to reduce all function values simultaneously!</p>
            </div>
        </div>
        
        <!-- Simulation Tab -->
        <div id="simulation" class="tab-content">
            <div class="main-content">
                <div class="visualization-panel">
                    <h3 style="margin-top: 0; color: #2c3e50;">Function Contours & Convergence Path</h3>
                    <canvas id="canvas" width="700" height="500"></canvas>
                    <div id="debugInfo" class="debug">Click "Interactive Simulation" tab to start</div>
                </div>
                
                <div class="controls">
                    <div class="control-group">
                        <h3>System of Equations</h3>
                        <div class="system-btn active" data-system="simple">
                            <div class="system-name">Simple System</div>
                            <div class="system-equations">f₁: x² + y² - 1 = 0<br>f₂: x - y = 0</div>
                        </div>
                        <div class="system-btn" data-system="circle_line">
                            <div class="system-name">Circle & Line</div>
                            <div class="system-equations">f₁: x² + y² - 1 = 0<br>f₂: x + y - 1 = 0</div>
                        </div>
                        <div class="system-btn" data-system="nonlinear">
                            <div class="system-name">Complex Nonlinear</div>
                            <div class="system-equations">f₁: (x-y)² - 1 = 0<br>f₂: e^x - y - 2 = 0</div>
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <h3>Starting Point</h3>
                        <div class="starting-point">
                            <div class="input-group">
                                <label for="startX">Initial x₀:</label>
                                <input type="number" id="startX" value="1.5" step="0.1">
                            </div>
                            <div class="input-group">
                                <label for="startY">Initial y₀:</label>
                                <input type="number" id="startY" value="0.5" step="0.1">
                            </div>
                        </div>
                    </div>
                    
                    <div class="action-buttons">
                        <button id="stepBtn" class="btn-primary">Next Step</button>
                        <button id="resetBtn" class="btn-secondary">Reset</button>
                    </div>
                    
                    <button id="animateBtn" class="btn-primary" style="width: 100%; margin-bottom: 20px;">Auto Solve</button>
                    
                    <div class="info-panel">
                        <div class="iteration-info">
                            <div class="info-item">
                                <span id="iterationCount" class="info-value">0</span>
                                <div class="info-label">Iteration</div>
                            </div>
                            <div class="info-item">
                                <span id="residualNorm" class="info-value">--</span>
                                <div class="info-label">||F(x)||</div>
                            </div>
                        </div>
                        
                        <div class="current-values">
                            <h4>Current Point</h4>
                            <div class="values-grid">
                                <div class="value-item">x = <span id="currentX">0.800</span></div>
                                <div class="value-item">y = <span id="currentY">0.200</span></div>
                            </div>
                            <div class="values-grid" style="margin-top: 10px;">
                                <div class="value-item">f₁ = <span id="f1Value">--</span></div>
                                <div class="value-item">f₂ = <span id="f2Value">--</span></div>
                            </div>
                        </div>
                        
                        <div class="jacobian-display">
                            <h4>Jacobian Matrix J(x,y)</h4>
                            <div class="matrix" id="jacobianMatrix">Click step to see Jacobian</div>
                        </div>
                        
                        <div class="explanation">
                            <strong>Newton's Method Formula:</strong><br>
                            <strong>x</strong><sub>k+1</sub> = <strong>x</strong><sub>k</sub> - J(<strong>x</strong><sub>k</sub>)<sup>-1</sup> F(<strong>x</strong><sub>k</sub>)<br><br>
                            Where J is the Jacobian matrix and F is the vector of functions.
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Code Tab -->
        <div id="code" class="tab-content">
            <div style="max-width: 1200px; margin: 0 auto;">
                <div class="concept-card" style="margin-bottom: 30px;">
                    <h3>💻 MATLAB Implementation of Newton's Method for Systems</h3>
                    <p>This complete MATLAB implementation shows how to solve nonlinear systems using Newton's method with automatic Jacobian computation and robust error handling.</p>
                </div>
                
                <div style="background: #2d3748; color: #e2e8f0; border-radius: 15px; padding: 25px; margin-bottom: 30px; font-family: 'Courier New', monospace; font-size: 14px; line-height: 1.6; overflow-x: auto;">
<pre style="margin: 0; white-space: pre-wrap;">
<span style="color: #68d391;">function</span> [x, history] = <span style="color: #fbb6ce;">newton_system</span>(fun, jac, x0, options)
<span style="color: #a0aec0;">% NEWTON_SYSTEM - Solve nonlinear system using Newton's method
%
% Inputs:
%   fun     - Function handle returning [f1; f2; ...] (column vector)
%   jac     - Function handle returning Jacobian matrix
%   x0      - Initial guess [x0; y0; ...] (column vector)
%   options - Structure with fields: tol, maxiter, verbose
%
% Outputs:
%   x       - Solution vector
%   history - Structure with iteration history</span>

<span style="color: #90cdf4;">%% Default parameters</span>
<span style="color: #68d391;">if</span> <span style="color: #fbb6ce;">nargin</span> < 4
    options = <span style="color: #fbb6ce;">struct</span>();
<span style="color: #68d391;">end</span>

<span style="color: #90cdf4;">% Set default values</span>
tol = <span style="color: #fbb6ce;">getfield</span>(options, <span style="color: #fed7d7;">'tol'</span>, 1e-8);      <span style="color: #a0aec0;">% Convergence tolerance</span>
maxiter = <span style="color: #fbb6ce;">getfield</span>(options, <span style="color: #fed7d7;">'maxiter'</span>, 50); <span style="color: #a0aec0;">% Maximum iterations</span>
verbose = <span style="color: #fbb6ce;">getfield</span>(options, <span style="color: #fed7d7;">'verbose'</span>, <span style="color: #68d391;">true</span>); <span style="color: #a0aec0;">% Print progress</span>

<span style="color: #90cdf4;">%% Initialize</span>
x = x0(:);  <span style="color: #a0aec0;">% Ensure column vector</span>
n = <span style="color: #fbb6ce;">length</span>(x);

<span style="color: #90cdf4;">% Initialize history tracking</span>
history.x = <span style="color: #fbb6ce;">zeros</span>(n, maxiter+1);
history.f = <span style="color: #fbb6ce;">zeros</span>(n, maxiter+1);
history.norm_f = <span style="color: #fbb6ce;">zeros</span>(1, maxiter+1);
history.step_size = <span style="color: #fbb6ce;">zeros</span>(1, maxiter);

<span style="color: #68d391;">if</span> verbose
    <span style="color: #fbb6ce;">fprintf</span>(<span style="color: #fed7d7;">'Newton''s Method for Nonlinear Systems\n'</span>);
    <span style="color: #fbb6ce;">fprintf</span>(<span style="color: #fed7d7;">'=====================================\n'</span>);
    <span style="color: #fbb6ce;">fprintf</span>(<span style="color: #fed7d7;">'Iter\t||F(x)||\t\tStep Size\tCondition\n'</span>);
<span style="color: #68d391;">end</span>

<span style="color: #90cdf4;">%% Main Newton iteration loop</span>
<span style="color: #68d391;">for</span> k = 1:maxiter
    <span style="color: #90cdf4;">% Evaluate function and Jacobian at current point</span>
    F = <span style="color: #fbb6ce;">feval</span>(fun, x);                <span style="color: #a0aec0;">% Function values F(x)</span>
    J = <span style="color: #fbb6ce;">feval</span>(jac, x);                <span style="color: #a0aec0;">% Jacobian matrix J(x)</span>
    
    <span style="color: #90cdf4;">% Store current iteration data</span>
    history.x(:, k) = x;
    history.f(:, k) = F;
    norm_f = <span style="color: #fbb6ce;">norm</span>(F);
    history.norm_f(k) = norm_f;
    
    <span style="color: #90cdf4;">% Check convergence</span>
    <span style="color: #68d391;">if</span> norm_f < tol
        <span style="color: #68d391;">if</span> verbose
            <span style="color: #fbb6ce;">fprintf</span>(<span style="color: #fed7d7;">'%d\t%.6e\t\t---\t\tCONVERGED\n'</span>, k-1, norm_f);
            <span style="color: #fbb6ce;">fprintf</span>(<span style="color: #fed7d7;">'Solution found in %d iterations\n'</span>, k-1);
        <span style="color: #68d391;">end</span>
        history.iterations = k-1;
        <span style="color: #68d391;">return</span>;
    <span style="color: #68d391;">end</span>
    
    <span style="color: #90cdf4;">% Check if Jacobian is singular</span>
    cond_J = <span style="color: #fbb6ce;">cond</span>(J);
    <span style="color: #68d391;">if</span> cond_J > 1e12
        <span style="color: #fbb6ce;">warning</span>(<span style="color: #fed7d7;">'Jacobian is nearly singular (cond = %.2e)'</span>, cond_J);
        <span style="color: #68d391;">break</span>;
    <span style="color: #68d391;">end</span>
    
    <span style="color: #90cdf4;">% Solve linear system: J(x) * delta = -F(x)</span>
    <span style="color: #68d391;">try</span>
        delta = -J \ F;  <span style="color: #a0aec0;">% Newton step: solve J*delta = -F</span>
    <span style="color: #68d391;">catch</span>
        <span style="color: #fbb6ce;">error</span>(<span style="color: #fed7d7;">'Failed to solve linear system. Jacobian may be singular.'</span>);
    <span style="color: #68d391;">end</span>
    
    <span style="color: #90cdf4;">% Update solution</span>
    x_new = x + delta;                   <span style="color: #a0aec0;">% Newton update</span>
    step_size = <span style="color: #fbb6ce;">norm</span>(delta);
    history.step_size(k) = step_size;
    
    <span style="color: #68d391;">if</span> verbose
        <span style="color: #fbb6ce;">fprintf</span>(<span style="color: #fed7d7;">'%d\t%.6e\t%.6e\t%.2e\n'</span>, k-1, norm_f, step_size, cond_J);
    <span style="color: #68d391;">end</span>
    
    <span style="color: #90cdf4;">% Move to next iteration</span>
    x = x_new;
<span style="color: #68d391;">end</span>

<span style="color: #90cdf4;">% If we reach here, maximum iterations exceeded</span>
<span style="color: #fbb6ce;">warning</span>(<span style="color: #fed7d7;">'Maximum iterations (%d) reached without convergence'</span>, maxiter);
history.iterations = maxiter;

<span style="color: #68d391;">end</span>

<span style="color: #90cdf4;">%% Helper function for default struct fields</span>
<span style="color: #68d391;">function</span> value = <span style="color: #fbb6ce;">getfield</span>(s, field, default)
    <span style="color: #68d391;">if</span> <span style="color: #fbb6ce;">isfield</span>(s, field)
        value = s.(field);
    <span style="color: #68d391;">else</span>
        value = default;
    <span style="color: #68d391;">end</span>
<span style="color: #68d391;">end</span>
</pre>
                </div>
                
                <div class="learning-grid">
                    <div class="concept-card">
                        <h3>🔧 Example Usage: Circle and Line System</h3>
                        <div style="background: #2d3748; color: #e2e8f0; border-radius: 10px; padding: 15px; font-family: 'Courier New', monospace; font-size: 13px; margin: 15px 0;">
<pre style="margin: 0;">
<span style="color: #90cdf4;">% Define the system: circle and line</span>
<span style="color: #68d391;">function</span> F = <span style="color: #fbb6ce;">system_fun</span>(x)
    F = [x(1)^2 + x(2)^2 - 1;  <span style="color: #a0aec0;">% Circle</span>
         x(1) - x(2)];          <span style="color: #a0aec0;">% Line</span>
<span style="color: #68d391;">end</span>

<span style="color: #90cdf4;">% Define the Jacobian</span>
<span style="color: #68d391;">function</span> J = <span style="color: #fbb6ce;">jacobian_fun</span>(x)
    J = [2*x(1), 2*x(2);       <span style="color: #a0aec0;">% ∂f/∂x, ∂f/∂y</span>
         1,      -1];          <span style="color: #a0aec0;">% ∂g/∂x, ∂g/∂y</span>
<span style="color: #68d391;">end</span>

<span style="color: #90cdf4;">% Solve the system</span>
x0 = [0.8; 0.2];              <span style="color: #a0aec0;">% Initial guess</span>
options.tol = 1e-10;
options.maxiter = 20;
options.verbose = <span style="color: #68d391;">true</span>;

[solution, hist] = <span style="color: #fbb6ce;">newton_system</span>(@system_fun, @jacobian_fun, x0, options);

<span style="color: #fbb6ce;">fprintf</span>(<span style="color: #fed7d7;">'Final solution: x = %.8f, y = %.8f\n'</span>, solution(1), solution(2));
</pre>
                        </div>
                    </div>
                    
                    <div class="concept-card">
                        <h3>🧮 Example: Complex Nonlinear System</h3>
                        <div style="background: #2d3748; color: #e2e8f0; border-radius: 10px; padding: 15px; font-family: 'Courier New', monospace; font-size: 13px; margin: 15px 0;">
<pre style="margin: 0;">
<span style="color: #90cdf4;">% Complex system with exponential</span>
<span style="color: #68d391;">function</span> F = <span style="color: #fbb6ce;">complex_system</span>(x)
    F = [(x(1)-x(2))^2 - 1;    <span style="color: #a0aec0;">% (x-y)² - 1</span>
         exp(x(1)) - x(2) - 2]; <span style="color: #a0aec0;">% e^x - y - 2</span>
<span style="color: #68d391;">end</span>

<span style="color: #68d391;">function</span> J = <span style="color: #fbb6ce;">complex_jacobian</span>(x)
    J = [2*(x(1)-x(2)), -2*(x(1)-x(2)); <span style="color: #a0aec0;">% ∂f/∂x, ∂f/∂y</span>
         exp(x(1)),     -1];             <span style="color: #a0aec0;">% ∂g/∂x, ∂g/∂y</span>
<span style="color: #68d391;">end</span>

<span style="color: #90cdf4;">% Solve with different starting points</span>
x0_list = [1.5, 0.5; 0.5, 1.0; 2.0, 3.0];

<span style="color: #68d391;">for</span> i = 1:<span style="color: #fbb6ce;">size</span>(x0_list, 1)
    x0 = x0_list(i, :)';
    [sol, hist] = <span style="color: #fbb6ce;">newton_system</span>(@complex_system, @complex_jacobian, x0);
    <span style="color: #fbb6ce;">fprintf</span>(<span style="color: #fed7d7;">'Start: [%.1f, %.1f] → Solution: [%.6f, %.6f]\n'</span>, ...
            x0(1), x0(2), sol(1), sol(2));
<span style="color: #68d391;">end</span>
</pre>
                        </div>
                    </div>
                </div>
                
                <div class="step-by-step">
                    <h3>🔍 Code Breakdown: Key Components</h3>
                    
                    <div class="step">
                        <div class="step-number">1</div>
                        <div class="step-content">
                            <div class="step-title">Function & Jacobian Evaluation</div>
                            <code>F = feval(fun, x); J = feval(jac, x);</code><br>
                            Computes the function values F(x) and Jacobian matrix J(x) at the current point.
                        </div>
                    </div>
                    
                    <div class="step">
                        <div class="step-number">2</div>
                        <div class="step-content">
                            <div class="step-title">Convergence Check</div>
                            <code>if norm(F) < tol</code><br>
                            Tests if ||F(x)|| is small enough to consider the system solved.
                        </div>
                    </div>
                    
                    <div class="step">
                        <div class="step-number">3</div>
                        <div class="step-content">
                            <div class="step-title">Singularity Check</div>
                            <code>cond_J = cond(J); if cond_J > 1e12</code><br>
                            Ensures the Jacobian is well-conditioned before attempting to solve the linear system.
                        </div>
                    </div>
                    
                    <div class="step">
                        <div class="step-number">4</div>
                        <div class="step-content">
                            <div class="step-title">Newton Step Computation</div>
                            <code>delta = -J \ F;</code><br>
                            Solves the linear system J(x)δ = -F(x) to find the Newton step direction.
                        </div>
                    </div>
                    
                    <div class="step">
                        <div class="step-number">5</div>
                        <div class="step-content">
                            <div class="step-title">Solution Update</div>
                            <code>x = x + delta;</code><br>
                            Updates the current estimate using the computed Newton step.
                        </div>
                    </div>
                    
                    <div class="step">
                        <div class="step-number">6</div>
                        <div class="step-content">
                            <div class="step-title">History Tracking</div>
                            <code>history.x(:,k) = x; history.norm_f(k) = norm(F);</code><br>
                            Records iteration history for analysis and plotting convergence behavior.
                        </div>
                    </div>
                </div>
                
                <div class="matrix-example">
                    <h4>📊 Advanced Features</h4>
                    <ul style="line-height: 1.8;">
                        <li><strong>Robust Error Handling:</strong> Checks for singular Jacobians and numerical issues</li>
                        <li><strong>Convergence Monitoring:</strong> Tracks ||F(x)||, step sizes, and condition numbers</li>
                        <li><strong>Flexible Interface:</strong> Configurable tolerance, maximum iterations, and verbosity</li>
                        <li><strong>History Tracking:</strong> Complete record of the iteration process for analysis</li>
                        <li><strong>Multiple Systems:</strong> Works with any size system (2×2, 3×3, n×n)</li>
                    </ul>
                    
                    <h4 style="margin-top: 20px;">💡 Pro Tips</h4>
                    <ul style="line-height: 1.8;">
                        <li><strong>Starting Point:</strong> Choose x₀ reasonably close to the expected solution</li>
                        <li><strong>Scaling:</strong> For badly scaled problems, consider variable scaling</li>
                        <li><strong>Line Search:</strong> For difficult problems, add a line search for robustness</li>
                        <li><strong>Automatic Differentiation:</strong> Use MATLAB's Symbolic Toolbox for complex Jacobians</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <script>
        let solver = null;

        // Tab switching functionality
        function showTab(tabName) {
            // Hide all tab contents
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Remove active class from all nav tabs
            document.querySelectorAll('.nav-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Show selected tab
            document.getElementById(tabName).classList.add('active');
            
            // Add active class to clicked nav tab
            event.target.classList.add('active');
            
            // Initialize solver when simulation tab is shown
            if (tabName === 'simulation' && !solver) {
                console.log('Initializing solver for simulation tab...');
                setTimeout(() => {
                    solver = new NewtonSystemSolver();
                }, 100);
            }
        }

        class NewtonSystemSolver {
            constructor() {
                console.log('Initializing Newton System Solver...');
                
                this.canvas = document.getElementById('canvas');
                if (!this.canvas) {
                    console.error('Canvas not found!');
                    return;
                }
                
                this.ctx = this.canvas.getContext('2d');
                this.width = this.canvas.width;
                this.height = this.canvas.height;
                
                this.systemType = 'simple';
                this.startX = 1.5;
                this.startY = 0.5;
                this.currentX = 1.5;
                this.currentY = 0.5;
                this.iteration = 0;
                this.path = [];
                this.isAnimating = false;
                this.animationTimeout = null;
                
                this.scale = 100;  // Reduced scale for better complex system visibility
                this.offsetX = this.width / 2;
                this.offsetY = this.height / 2;
                
                this.setupEventListeners();
                this.reset();
                this.debug('Solver initialized successfully');
            }
            
            debug(message) {
                console.log(message);
                const debugDiv = document.getElementById('debugInfo');
                if (debugDiv) {
                    debugDiv.innerHTML = message;
                }
            }
            
            setupEventListeners() {
                console.log('Setting up event listeners...');
                
                // System selection
                document.querySelectorAll('.system-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelector('.system-btn.active')?.classList.remove('active');
                        e.currentTarget.classList.add('active');
                        this.systemType = e.currentTarget.dataset.system;
                        this.debug(`Switched to system: ${this.systemType}`);
                        this.reset();
                    });
                });
                
                // Starting point inputs
                const startXInput = document.getElementById('startX');
                const startYInput = document.getElementById('startY');
                
                if (startXInput) {
                    startXInput.addEventListener('input', (e) => {
                        this.startX = parseFloat(e.target.value) || 0;
                        this.reset();
                    });
                }
                
                if (startYInput) {
                    startYInput.addEventListener('input', (e) => {
                        this.startY = parseFloat(e.target.value) || 0;
                        this.reset();
                    });
                }
                
                // Control buttons
                const stepBtn = document.getElementById('stepBtn');
                const resetBtn = document.getElementById('resetBtn');
                const animateBtn = document.getElementById('animateBtn');
                
                if (stepBtn) {
                    stepBtn.addEventListener('click', () => {
                        console.log('Step button clicked');
                        this.step();
                    });
                }
                
                if (resetBtn) {
                    resetBtn.addEventListener('click', () => {
                        console.log('Reset button clicked');
                        this.reset();
                    });
                }
                
                if (animateBtn) {
                    animateBtn.addEventListener('click', () => {
                        console.log('Animate button clicked');
                        this.toggleAnimation();
                    });
                }
                
                console.log('Event listeners set up successfully');
            }
            
            // System of equations
            getSystemValue(x, y) {
                switch(this.systemType) {
                    case 'simple':
                        return [
                            x*x + y*y - 1,  // Circle: x² + y² = 1
                            x - y           // Line: x = y
                        ];
                    case 'circle_line':
                        return [
                            x*x + y*y - 1,  // Circle: x² + y² = 1
                            x + y - 1       // Line: x + y = 1
                        ];
                    case 'nonlinear':
                        return [
                            (x-y)*(x-y) - 1,    // Simplified: (x-y)² - 1 = 0
                            Math.exp(x) - y - 2 // Exponential: e^x - y - 2 = 0
                        ];
                    default:
                        return [x*x + y*y - 1, x - y];
                }
            }
            
            // Jacobian matrix
            getJacobian(x, y) {
                switch(this.systemType) {
                    case 'simple':
                        return [
                            [2*x, 2*y],  // ∂f₁/∂x, ∂f₁/∂y
                            [1, -1]      // ∂f₂/∂x, ∂f₂/∂y
                        ];
                    case 'circle_line':
                        return [
                            [2*x, 2*y],  // ∂f₁/∂x, ∂f₁/∂y
                            [1, 1]       // ∂f₂/∂x, ∂f₂/∂y
                        ];
                    case 'nonlinear':
                        return [
                            [2*(x-y), -2*(x-y)],     // ∂f₁/∂x, ∂f₁/∂y for (x-y)²-1
                            [Math.exp(x), -1]        // ∂f₂/∂x, ∂f₂/∂y for e^x-y-2
                        ];
                    default:
                        return [[2*x, 2*y], [1, -1]];
                }
            }
            
            // Matrix operations
            determinant2x2(matrix) {
                const [[a, b], [c, d]] = matrix;
                return a*d - b*c;
            }
            
            invertMatrix2x2(matrix) {
                const [[a, b], [c, d]] = matrix;
                const det = this.determinant2x2(matrix);
                
                if (Math.abs(det) < 1e-12) {
                    throw new Error('Singular matrix - determinant is zero');
                }
                
                return [
                    [d/det, -b/det],
                    [-c/det, a/det]
                ];
            }
            
            matrixVectorMultiply(matrix, vector) {
                const [[a, b], [c, d]] = matrix;
                const [x, y] = vector;
                return [a*x + b*y, c*x + d*y];
            }
            
            // Coordinate transformations
            mathToScreen(mathX, mathY) {
                return {
                    x: mathX * this.scale + this.offsetX,
                    y: -mathY * this.scale + this.offsetY
                };
            }
            
            screenToMath(screenX, screenY) {
                return {
                    x: (screenX - this.offsetX) / this.scale,
                    y: -(screenY - this.offsetY) / this.scale
                };
            }
            
            // Drawing functions
            drawAxes() {
                this.ctx.strokeStyle = '#ddd';
                this.ctx.lineWidth = 1;
                
                // X-axis
                this.ctx.beginPath();
                this.ctx.moveTo(0, this.offsetY);
                this.ctx.lineTo(this.width, this.offsetY);
                this.ctx.stroke();
                
                // Y-axis
                this.ctx.beginPath();
                this.ctx.moveTo(this.offsetX, 0);
                this.ctx.lineTo(this.offsetX, this.height);
                this.ctx.stroke();
                
                // Grid and labels
                this.ctx.fillStyle = '#999';
                this.ctx.font = '12px Arial';
                
                for (let i = -2; i <= 2; i++) {
                    if (i === 0) continue;
                    
                    const screenX = this.mathToScreen(i, 0).x;
                    const screenY = this.mathToScreen(0, i).y;
                    
                    if (screenX >= 0 && screenX <= this.width) {
                        this.ctx.strokeStyle = '#f0f0f0';
                        this.ctx.beginPath();
                        this.ctx.moveTo(screenX, 0);
                        this.ctx.lineTo(screenX, this.height);
                        this.ctx.stroke();
                        
                        this.ctx.fillStyle = '#999';
                        this.ctx.fillText(i.toString(), screenX - 5, this.offsetY + 15);
                    }
                    
                    if (screenY >= 0 && screenY <= this.height) {
                        this.ctx.strokeStyle = '#f0f0f0';
                        this.ctx.beginPath();
                        this.ctx.moveTo(0, screenY);
                        this.ctx.lineTo(this.width, screenY);
                        this.ctx.stroke();
                        
                        this.ctx.fillStyle = '#999';
                        this.ctx.fillText(i.toString(), this.offsetX + 5, screenY + 5);
                    }
                }
            }
            
            drawContours() {
                // Draw contours based on system type
                if (this.systemType === 'simple' || this.systemType === 'circle_line') {
                    // Draw unit circle (f1 = 0)
                    this.ctx.strokeStyle = '#e74c3c';
                    this.ctx.lineWidth = 3;
                    this.ctx.beginPath();
                    const centerScreen = this.mathToScreen(0, 0);
                    this.ctx.arc(centerScreen.x, centerScreen.y, this.scale, 0, 2 * Math.PI);
                    this.ctx.stroke();
                    
                    // Draw the second function's zero level
                    this.ctx.strokeStyle = '#2ecc71';
                    this.ctx.lineWidth = 3;
                    this.ctx.beginPath();
                    
                    if (this.systemType === 'simple') {
                        // Line x = y
                        const start = this.mathToScreen(-2, -2);
                        const end = this.mathToScreen(2, 2);
                        this.ctx.moveTo(start.x, start.y);
                        this.ctx.lineTo(end.x, end.y);
                    } else if (this.systemType === 'circle_line') {
                        // Line x + y = 1
                        const start = this.mathToScreen(-1, 2);
                        const end = this.mathToScreen(2, -1);
                        this.ctx.moveTo(start.x, start.y);
                        this.ctx.lineTo(end.x, end.y);
                    }
                    
                    this.ctx.stroke();
                } else if (this.systemType === 'nonlinear') {
                    // Draw contours for the complex system using sampling
                    this.drawComplexContours();
                }
                
                // Add legend
                this.ctx.font = '14px Arial';
                this.ctx.fillStyle = '#e74c3c';
                this.ctx.fillText('f₁(x,y) = 0', 10, 30);
                this.ctx.fillStyle = '#2ecc71';
                this.ctx.fillText('f₂(x,y) = 0', 10, 50);
            }
            
            drawComplexContours() {
                // For the complex system, let's draw some level curves manually
                
                // Draw f2 = 0: e^x - y - 2 = 0, so y = e^x - 2
                this.ctx.strokeStyle = '#2ecc71';
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                
                let first = true;
                for (let x = -2; x <= 2; x += 0.05) {
                    const y = Math.exp(x) - 2;
                    if (y >= -3 && y <= 3) { // Only draw within reasonable bounds
                        const screen = this.mathToScreen(x, y);
                        if (screen.x >= 0 && screen.x <= this.width && screen.y >= 0 && screen.y <= this.height) {
                            if (first) {
                                this.ctx.moveTo(screen.x, screen.y);
                                first = false;
                            } else {
                                this.ctx.lineTo(screen.x, screen.y);
                            }
                        }
                    }
                }
                this.ctx.stroke();
                
                // For f1 = 0: x² + y² - 2xy - 1 = 0, which is (x-y)² - 1 = 0
                // This gives us x - y = ±1, so y = x ± 1
                this.ctx.strokeStyle = '#e74c3c';
                this.ctx.lineWidth = 3;
                
                // Draw y = x + 1
                this.ctx.beginPath();
                const start1 = this.mathToScreen(-2, -1);
                const end1 = this.mathToScreen(2, 3);
                this.ctx.moveTo(start1.x, start1.y);
                this.ctx.lineTo(end1.x, end1.y);
                this.ctx.stroke();
                
                // Draw y = x - 1
                this.ctx.beginPath();
                const start2 = this.mathToScreen(-2, -3);
                const end2 = this.mathToScreen(2, 1);
                this.ctx.moveTo(start2.x, start2.y);
                this.ctx.lineTo(end2.x, end2.y);
                this.ctx.stroke();
                
                // Add some sample points to show the curves more clearly
                this.drawSamplePoints();
            }
            
            drawSamplePoints() {
                const resolution = 8;
                const tolerance = 0.15;
                
                this.ctx.fillStyle = '#e74c3c';
                for (let screenX = 0; screenX < this.width; screenX += resolution) {
                    for (let screenY = 0; screenY < this.height; screenY += resolution) {
                        const math = this.screenToMath(screenX, screenY);
                        
                        if (math.x >= -2.5 && math.x <= 2.5 && math.y >= -2.5 && math.y <= 2.5) {
                            const values = this.getSystemValue(math.x, math.y);
                            
                            // Draw points where f1 ≈ 0
                            if (Math.abs(values[0]) < tolerance) {
                                this.ctx.fillStyle = '#e74c3c';
                                this.ctx.fillRect(screenX-2, screenY-2, 4, 4);
                            }
                            
                            // Draw points where f2 ≈ 0  
                            if (Math.abs(values[1]) < tolerance) {
                                this.ctx.fillStyle = '#2ecc71';
                                this.ctx.fillRect(screenX-2, screenY-2, 4, 4);
                            }
                        }
                    }
                }
            }
            
            drawPath() {
                if (this.path.length === 0) return;
                
                // Draw path lines with arrows
                if (this.path.length > 1) {
                    this.ctx.strokeStyle = '#9b59b6';
                    this.ctx.lineWidth = 3;
                    this.ctx.setLineDash([8, 4]);
                    
                    for (let i = 0; i < this.path.length - 1; i++) {
                        const start = this.mathToScreen(this.path[i].x, this.path[i].y);
                        const end = this.mathToScreen(this.path[i + 1].x, this.path[i + 1].y);
                        
                        // Draw line
                        this.ctx.beginPath();
                        this.ctx.moveTo(start.x, start.y);
                        this.ctx.lineTo(end.x, end.y);
                        this.ctx.stroke();
                        
                        // Draw small arrow at end
                        this.drawSmallArrow(start.x, start.y, end.x, end.y);
                    }
                    
                    this.ctx.setLineDash([]);
                }
                
                
                // Draw points with clean labels
                this.path.forEach((point, index) => {
                    const screen = this.mathToScreen(point.x, point.y);
                    
                    console.log(`Drawing point ${index}: (${point.x}, ${point.y}) -> screen (${screen.x}, ${screen.y})`);
                    
                    // Extend the drawing bounds for complex system
                    const bounds = this.systemType === 'nonlinear' ? 100 : 50;
                    
                    if (screen.x >= -bounds && screen.x <= this.width + bounds && 
                        screen.y >= -bounds && screen.y <= this.height + bounds) {
                        
                        let size, color;
                        
                        if (index === 0) {
                            size = 10;
                            color = '#e67e22'; // Orange for start
                        } else if (index === this.path.length - 1) {
                            size = 12;
                            color = '#e74c3c'; // Red for current
                        } else {
                            size = 8;
                            color = '#9b59b6'; // Purple for intermediate
                        }
                        
                        // Draw point with shadow
                        this.ctx.shadowColor = 'rgba(0,0,0,0.3)';
                        this.ctx.shadowBlur = 4;
                        this.ctx.shadowOffsetX = 2;
                        this.ctx.shadowOffsetY = 2;
                        
                        this.ctx.fillStyle = color;
                        this.ctx.beginPath();
                        this.ctx.arc(screen.x, screen.y, size, 0, 2 * Math.PI);
                        this.ctx.fill();
                        
                        // Reset shadow
                        this.ctx.shadowColor = 'transparent';
                        this.ctx.shadowBlur = 0;
                        this.ctx.shadowOffsetX = 0;
                        this.ctx.shadowOffsetY = 0;
                        
                        // Add white border
                        this.ctx.strokeStyle = 'white';
                        this.ctx.lineWidth = 3;
                        this.ctx.stroke();
                        
                        // Simple numbered labels for intermediate points
                        if (index > 0 && index < this.path.length - 1) {
                            this.ctx.fillStyle = '#333';
                            this.ctx.font = 'bold 11px Arial';
                            this.ctx.fillText(index.toString(), screen.x + 15, screen.y - 10);
                        }
                        
                        // Special labels for start and current
                        if (index === 0) {
                            this.ctx.fillStyle = '#e67e22';
                            this.ctx.font = 'bold 12px Arial';
                            this.ctx.fillText('START', screen.x - 20, screen.y - 15);
                        } else if (index === this.path.length - 1) {
                            this.ctx.fillStyle = '#e74c3c';
                            this.ctx.font = 'bold 12px Arial';
                            this.ctx.fillText(`STEP ${index}`, screen.x - 25, screen.y - 18);
                            
                            // Show coordinates for current point only
                            const coordText = `(${point.x.toFixed(3)}, ${point.y.toFixed(3)})`;
                            this.ctx.fillStyle = '#2c3e50';
                            this.ctx.font = '11px Arial';
                            this.ctx.fillText(coordText, screen.x - 35, screen.y + 25);
                        }
                    } else {
                        console.log(`Point ${index} is outside drawing bounds`);
                    }
                });
                
                console.log('Path drawing completed');
            }
            
            drawSmallArrow(fromX, fromY, toX, toY) {
                const headLength = 8;
                const angle = Math.atan2(toY - fromY, toX - fromX);
                
                this.ctx.strokeStyle = '#9b59b6';
                this.ctx.fillStyle = '#9b59b6';
                this.ctx.lineWidth = 2;
                
                // Draw small arrow head
                this.ctx.beginPath();
                this.ctx.moveTo(toX, toY);
                this.ctx.lineTo(toX - headLength * Math.cos(angle - Math.PI / 6), 
                              toY - headLength * Math.sin(angle - Math.PI / 6));
                this.ctx.lineTo(toX - headLength * Math.cos(angle + Math.PI / 6), 
                              toY - headLength * Math.sin(angle + Math.PI / 6));
                this.ctx.closePath();
                this.ctx.fill();
            }
            
            step() {
                console.log(`Starting step ${this.iteration + 1}`);
                console.log(`Current state - isAnimating: ${this.isAnimating}, currentX: ${this.currentX}, currentY: ${this.currentY}`);
                
                try {
                    const F = this.getSystemValue(this.currentX, this.currentY);
                    const J = this.getJacobian(this.currentX, this.currentY);
                    
                    console.log(`Current point: (${this.currentX}, ${this.currentY})`);
                    console.log(`F(x,y) = [${F[0]}, ${F[1]}]`);
                    console.log(`J(x,y) = [[${J[0][0]}, ${J[0][1]}], [${J[1][0]}, ${J[1][1]}]]`);
                    
                    // Check for singular matrix
                    const det = this.determinant2x2(J);
                    console.log(`Determinant: ${det}`);
                    
                    if (Math.abs(det) < 1e-12) {
                        console.log('Singular matrix detected');
                        alert('Jacobian matrix is singular (determinant ≈ 0). Try a different starting point.');
                        this.stopAnimation();
                        return;
                    }
                    
                    const JInv = this.invertMatrix2x2(J);
                    const delta = this.matrixVectorMultiply(JInv, F);
                    
                    console.log(`Delta: [${delta[0]}, ${delta[1]}]`);
                    
                    const newX = this.currentX - delta[0];
                    const newY = this.currentY - delta[1];
                    
                    console.log(`New point: (${newX}, ${newY})`);
                    
                    this.currentX = newX;
                    this.currentY = newY;
                    this.iteration++;
                    
                    this.path.push({x: this.currentX, y: this.currentY});
                    
                    const residualNorm = Math.sqrt(F[0]*F[0] + F[1]*F[1]);
                    
                    this.debug(`Step ${this.iteration}: (${this.currentX.toFixed(4)}, ${this.currentY.toFixed(4)}), ||F|| = ${residualNorm.toExponential(3)}`);
                    
                    this.updateInfo();
                    this.draw();
                    
                    console.log(`Step ${this.iteration} completed successfully`);
                    
                    // Check convergence
                    if (residualNorm < 1e-8) {
                        console.log('Convergence achieved in step()');
                        alert(`Converged! Solution: (${this.currentX.toFixed(8)}, ${this.currentY.toFixed(8)})`);
                        this.stopAnimation();
                        return true; // Indicate convergence
                    }
                    
                    return false; // Continue iterating
                    
                } catch (error) {
                    console.error('Error in step:', error);
                    alert('Error: ' + error.message);
                    this.stopAnimation();
                    return true; // Stop on error
                }
            }
            
            reset() {
                console.log('Resetting solver');
                
                this.currentX = this.startX;
                this.currentY = this.startY;
                this.iteration = 0;
                this.path = [{x: this.currentX, y: this.currentY}];
                this.stopAnimation();
                
                console.log(`Reset to starting point: (${this.currentX}, ${this.currentY}) for system: ${this.systemType}`);
                
                // Force an immediate draw to show the starting point
                this.updateInfo();
                this.draw();
                
                // Additional debugging for complex system
                if (this.systemType === 'nonlinear') {
                    const F = this.getSystemValue(this.currentX, this.currentY);
                    const J = this.getJacobian(this.currentX, this.currentY);
                    console.log(`Complex system initial values:`);
                    console.log(`F(${this.currentX}, ${this.currentY}) = [${F[0]}, ${F[1]}]`);
                    console.log(`J(${this.currentX}, ${this.currentY}) = [[${J[0][0]}, ${J[0][1]}], [${J[1][0]}, ${J[1][1]}]]`);
                    
                    const screen = this.mathToScreen(this.currentX, this.currentY);
                    console.log(`Screen coordinates: (${screen.x}, ${screen.y})`);
                    console.log(`Canvas bounds: ${this.width} x ${this.height}`);
                }
            }
            
            updateInfo() {
                document.getElementById('iterationCount').textContent = this.iteration;
                document.getElementById('currentX').textContent = this.currentX.toFixed(6);
                document.getElementById('currentY').textContent = this.currentY.toFixed(6);
                
                const F = this.getSystemValue(this.currentX, this.currentY);
                const residualNorm = Math.sqrt(F[0]*F[0] + F[1]*F[1]);
                document.getElementById('residualNorm').textContent = residualNorm.toExponential(3);
                
                // Update function values
                document.getElementById('f1Value').textContent = F[0].toFixed(6);
                document.getElementById('f2Value').textContent = F[1].toFixed(6);
                
                // Update Jacobian display
                const J = this.getJacobian(this.currentX, this.currentY);
                document.getElementById('jacobianMatrix').innerHTML = 
                    `[${J[0][0].toFixed(3)}  ${J[0][1].toFixed(3)}]<br>[${J[1][0].toFixed(3)}  ${J[1][1].toFixed(3)}]`;
            }
            
            toggleAnimation() {
                console.log('Toggle animation called, current state:', this.isAnimating);
                if (this.isAnimating) {
                    this.stopAnimation();
                } else {
                    this.startAnimation();
                }
            }
            
            startAnimation() {
                console.log('Starting animation...');
                this.isAnimating = true;
                const btn = document.getElementById('animateBtn');
                const stepBtn = document.getElementById('stepBtn');
                
                if (btn) {
                    btn.textContent = 'Stop Animation';
                    console.log('Button text changed to Stop Animation');
                }
                if (stepBtn) stepBtn.disabled = true;
                
                // Start the animation
                this.animate();
            }
            
            stopAnimation() {
                console.log('Stopping animation...');
                this.isAnimating = false;
                const btn = document.getElementById('animateBtn');
                const stepBtn = document.getElementById('stepBtn');
                
                if (btn) {
                    btn.textContent = 'Auto Solve';
                    console.log('Button text changed to Auto Solve');
                }
                if (stepBtn) stepBtn.disabled = false;
                
                if (this.animationTimeout) {
                    clearTimeout(this.animationTimeout);
                    this.animationTimeout = null;
                    console.log('Animation timeout cleared');
                }
            }
            
            animate() {
                console.log('=== ANIMATE CALLED ===');
                console.log('isAnimating:', this.isAnimating);
                console.log('Current iteration:', this.iteration);
                
                if (!this.isAnimating) {
                    console.log('Animation stopped, exiting animate()');
                    return;
                }
                
                // Perform one step
                console.log('About to call step()...');
                const shouldStop = this.step();
                
                if (shouldStop) {
                    console.log('Step indicated we should stop');
                    return;
                }
                
                // Check if we should continue
                const F = this.getSystemValue(this.currentX, this.currentY);
                const residualNorm = Math.sqrt(F[0]*F[0] + F[1]*F[1]);
                console.log('Post-step residual norm:', residualNorm);
                console.log('Post-step iteration count:', this.iteration);
                
                if (residualNorm < 1e-8) {
                    console.log('Converged in animate()! Stopping animation');
                    this.stopAnimation();
                    alert(`Converged! Solution: (${this.currentX.toFixed(8)}, ${this.currentY.toFixed(8)})`);
                    return;
                }
                
                if (this.iteration >= 20) {
                    console.log('Max iterations reached in animate(), stopping');
                    this.stopAnimation();
                    alert('Maximum iterations reached');
                    return;
                }
                
                console.log('Scheduling next animation step...');
                this.animationTimeout = setTimeout(() => {
                    console.log('=== TIMEOUT FIRED ===');
                    console.log('isAnimating at timeout:', this.isAnimating);
                    if (this.isAnimating) {
                        this.animate();
                    } else {
                        console.log('Animation was stopped, not continuing');
                    }
                }, 1500);
                
                console.log('animate() function completed, timeout scheduled');
            }
            
            draw() {
                console.log(`Drawing system: ${this.systemType}, path length: ${this.path.length}`);
                this.ctx.clearRect(0, 0, this.width, this.height);
                
                this.drawAxes();
                this.drawContours();
                this.drawPath();
                this.drawInfoOverlay();
                console.log('Draw completed');
            }
            
            drawInfoOverlay() {
                console.log(`Drawing overlay for system: ${this.systemType}, path length: ${this.path.length}`);
                
                if (this.path.length === 0) {
                    console.log('No path points, skipping overlay');
                    return;
                }
                
                const currentPoint = this.path[this.path.length - 1];
                console.log(`Current point: (${currentPoint.x}, ${currentPoint.y})`);
                
                const F = this.getSystemValue(currentPoint.x, currentPoint.y);
                const J = this.getJacobian(currentPoint.x, currentPoint.y);
                const residualNorm = Math.sqrt(F[0]*F[0] + F[1]*F[1]);
                
                console.log(`Function values: f1=${F[0]}, f2=${F[1]}, norm=${residualNorm}`);
                
                // Position overlay at the bottom-left corner instead
                const overlayX = 20;
                const overlayY = this.height - 180;
                const overlayWidth = 280;
                const overlayHeight = 160;
                
                // Draw semi-transparent background
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                this.ctx.strokeStyle = '#333';
                this.ctx.lineWidth = 2;
                this.ctx.fillRect(overlayX, overlayY, overlayWidth, overlayHeight);
                this.ctx.strokeRect(overlayX, overlayY, overlayWidth, overlayHeight);
                
                // Title
                this.ctx.fillStyle = '#2c3e50';
                this.ctx.font = 'bold 14px Arial';
                this.ctx.fillText(`Newton Step ${this.iteration}`, overlayX + 10, overlayY + 20);
                
                // System type indicator
                this.ctx.fillStyle = '#7f8c8d';
                this.ctx.font = '11px Arial';
                const systemName = this.systemType === 'simple' ? 'Simple System' : 
                                 this.systemType === 'circle_line' ? 'Circle & Line' : 'Complex Nonlinear';
                this.ctx.fillText(`System: ${systemName}`, overlayX + 10, overlayY + 35);
                
                // Current point
                this.ctx.font = '12px monospace';
                this.ctx.fillStyle = '#333';
                this.ctx.fillText(`Point: (${currentPoint.x.toFixed(4)}, ${currentPoint.y.toFixed(4)})`, overlayX + 10, overlayY + 55);
                
                // Function values
                this.ctx.fillStyle = '#e74c3c';
                this.ctx.fillText(`f₁(x,y) = ${F[0].toFixed(6)}`, overlayX + 10, overlayY + 73);
                this.ctx.fillStyle = '#2ecc71';
                this.ctx.fillText(`f₂(x,y) = ${F[1].toFixed(6)}`, overlayX + 10, overlayY + 91);
                
                // Error (residual norm)
                this.ctx.fillStyle = '#9b59b6';
                this.ctx.font = 'bold 12px monospace';
                this.ctx.fillText(`||F(x)|| = ${residualNorm.toExponential(3)}`, overlayX + 10, overlayY + 113);
                
                // Jacobian determinant
                const det = this.determinant2x2(J);
                this.ctx.fillStyle = '#f39c12';
                this.ctx.font = '11px monospace';
                this.ctx.fillText(`det(J) = ${det.toFixed(4)}`, overlayX + 10, overlayY + 131);
                
                // Convergence status
                let status, statusColor;
                if (residualNorm < 1e-8) {
                    status = 'CONVERGED ✓';
                    statusColor = '#27ae60';
                } else if (residualNorm < 1e-4) {
                    status = 'CLOSE';
                    statusColor = '#f39c12';
                } else {
                    status = 'ITERATING...';
                    statusColor = '#e74c3c';
                }
                
                this.ctx.fillStyle = statusColor;
                this.ctx.font = 'bold 11px Arial';
                this.ctx.fillText(status, overlayX + 170, overlayY + 131);
                
                // If we have a previous point, show the step vector info
                if (this.path.length > 1) {
                    const prevPoint = this.path[this.path.length - 2];
                    const stepX = currentPoint.x - prevPoint.x;
                    const stepY = currentPoint.y - prevPoint.y;
                    const stepSize = Math.sqrt(stepX*stepX + stepY*stepY);
                    
                    this.ctx.fillStyle = '#7f8c8d';
                    this.ctx.font = '10px monospace';
                    this.ctx.fillText(`Step size: ${stepSize.toFixed(6)}`, overlayX + 10, overlayY + 149);
                }
                
                console.log('Overlay drawing completed');
            }
        }
        
        // Initialize when page loads - but only create solver when simulation tab is active
        window.addEventListener('load', () => {
            console.log('Page loaded');
        });
    </script>
</body>
</html>
